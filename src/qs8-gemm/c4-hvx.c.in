// Copyright 2025 Google LLC
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree.

$assert REQUANTIZATION == "FP32" or not REQUANTIZATION
$assert REQUANTIZATION in ["FP32", "RNDNU"] or not REQUANTIZATION
$assert DATATYPE in ["QC8", "QS8", "QD8", "QC4"]
$assert DATATYPE != "QC8" or REQUANTIZATION == "FP32"
$assert not DATATYPE in ["QD8", "QC4"] or not REQUANTIZATION
#include <assert.h>

#include <hexagon_types.h>
#include <hexagon_protos.h>
#include <hvx_hexagon_protos.h>

#include "src/xnnpack/gemm.h"
#include "src/xnnpack/intrinsics-polyfill.h"
#include "src/xnnpack/math.h"
#include "src/xnnpack/unaligned.h"


$DATATYPE_SPEC = {"QC8": "qs8_qc8w", "QD8": "qd8_f32_qc8w", "QS8": "qs8", "QU8": "qu8", "QC4": "qd8_f32_qc4w"}[DATATYPE]
$REQUANTIZATION_SPEC = "" if DATATYPE in ["QD8", "QC4"] else "_" + REQUANTIZATION.lower()
$PARAMS_STRUCT = REQUANTIZATION.lower() + "_scalar" if REQUANTIZATION else "scalar"
$PARAMS_TYPE = {"QC8": "union xnn_qs8_qc8w_conv_minmax_params", "QS8": "union xnn_qs8_conv_minmax_params", "QD8": "struct xnn_f32_minmax_params"}[DATATYPE]
$OUT_T = "float" if DATATYPE in ["QD8", "QC4"] else "int8_t"

void xnn_${DATATYPE_SPEC}_gemm_minmax${REQUANTIZATION_SPEC}_ukernel_${MR}x32c4__hvx(
    size_t mr,
    size_t nc,
    size_t kc,
    const int8_t* restrict a,
    size_t a_stride,
    const void* restrict w,
    ${OUT_T}* restrict c,
    size_t cm_stride,
    size_t cn_stride,
    const ${PARAMS_TYPE} params[restrict XNN_MIN_ELEMENTS(1)]) XNN_OOB_READS
{
  assert(mr != 0);
  assert(mr <= ${MR});
  assert(nc != 0);
  assert(kc != 0);
  assert(kc % sizeof(int8_t) == 0);
  assert(a != NULL);
  assert(w != NULL);
  assert(c != NULL);

  kc = round_up_po2(kc, 4 * sizeof(int8_t));
  const int8_t* a0 = a;
  ${OUT_T}* c0 = c;
  $for M in range(1, MR):
    const int8_t* a${M} = (const int8_t*) ((uintptr_t) a${M-1} + a_stride);
    ${OUT_T}* c${M} = (${OUT_T}*) ((uintptr_t) c${M-1} + cm_stride);
    $if M % 2 == 0:
      if XNN_UNPREDICTABLE(mr <= ${M}) {
        a${M} = a${M-1};
        c${M} = c${M-1};
      }
    $elif M + 1 == MR:
      if XNN_UNPREDICTABLE(mr != ${M+1}) {
        a${M} = a${M-1};
        c${M} = c${M-1};
      }
    $else:
      if XNN_UNPREDICTABLE(mr < ${M+1}) {
        a${M} = a${M-1};
        c${M} = c${M-1};
      }

  assert(params->${PARAMS_STRUCT}.output_zero_point)) == 2);
  const HVX_Vector voutput_zero_point = Q6_Vh_vsplat_R(params->${PARAMS_STRUCT}.output_zero_point);
  const HVX_Vector voutput_min = Q6_Vb_vsplat_R(params->${PARAMS_STRUCT}.output_min);
  const HVX_Vector voutput_max = Q6_Vb_vsplat_R(params->${PARAMS_STRUCT}.output_max);

  do {
    HVX_Vector vacc0x32 = *((HVX_Vector*)w); w = (const int32_t*) w + 32;
    $for M in range(1, MR):
      HVX_Vector vacc${M}x32 = vacc0x32;

    size_t k = kc;
    for (; k >= 4 * sizeof(int8_t); k -= 4 * sizeof(int8_t)) {
      $for M in range(MR):
        const HVX_Vector va${M}x0123 = Q6_V_vsplat_R(unaligned_load_s32(a${M})); a${M} += 4;

      const HVX_Vector vb32x0123 = *((HVX_Vector *)((int8_t *)w)); w = (const int8_t*) w + 128;

      $for M in range(MR):
         vacc${M}x32 = Q6_Vw_vrmpyacc_VwVbVb(vacc${M}x32, va${M}x0123, vb32x0123);
    }

    const HVX_Vector vscale32 = *((HVX_Vector *)w);
    w = (const float*) w + 32;
    $for M in range(MR):
      HVX_Vector vscaled${M}x32 = Q6_Vsf_equals_Vqf32(Q6_Vqf32_convert_Vw(vacc${M}x32));

    $for M in range(MR):
      vscaled${M}x32 = Q6_Vqf32_vmpy_VsfVsf(vscaled${M}x32, vscale32);

    $for M in range(MR):
      vacc${M}x32 = Q6_Vw_convert_Vqf32(vscaled${M}x32);

    $for M in range(MR):
      HVX_Vector vout${M}x32 = Q6_Vh_vpack_VwVw_sat(vacc${M}x32, vacc${M}x32);

    $for M in range(MR):
      vout${M}x32 = Q6_Vh_vadd_VhVh(vout${M}x32, voutput_zero_point);

    $for M in range(MR):
      vout${M}x32 = Q6_Vb_vpack_VhVh_sat(vout${M}x32, vout${M}x32);

    $for M in range(MR):
      vout${M}x32 = Q6_Vb_vmax_VbVb(vout${M}x32, voutput_min);

    $for M in range(MR):
      vout${M}x32 = Q6_Vb_vmin_VbVb(vout${M}x32, voutput_max);

    if XNN_LIKELY(nc >= 32) {
      $for M in range(MR):
        Q6_V_vstu_variable(c${M}, 32, vout${M}x32);
        c${M} = (${OUT_T}*) ((uintptr_t) c${M} + cn_stride);
        a${M} = (const int8_t*) ((uintptr_t) a${M} - kc);

      nc -= 32;
    } else {
      // Prepare mask for valid 8-bit elements (depends on nc).
      $for M in range(MR):
        Q6_V_vstu_variable(c${M}, nc, vout${M}x32);
      nc = 0;
    }
  } while (nc != 0);
}
