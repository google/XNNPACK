// Copyright 2023 Google LLC
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree.

$assert NR > 1
$assert KR > 1
#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <math.h>

#include "xnnpack/packw.h"

void xnn_qb4_packw_gemm_goi_ukernel_x${NR}c${KR}__scalar(
  size_t g,
  size_t nc,
  size_t kc,
  size_t nr,
  size_t kr,
  size_t sr,
  size_t bl,
  const uint8_t* weights,
  const int32_t* bias,
  const void* scale,
  int8_t* packed_weights,
  size_t extra_bytes_bl,
  size_t extra_bytes_n,
  const void* params)
{
  assert(g != 0);
  assert(nc != 0);
  assert(kc != 0);
  assert(nr == ${NR});
  assert(kr == ${KR});
  assert(sr == 1);
  assert(weights != NULL);
  assert(packed_weights != NULL);
  assert(extra_bytes_bl == nr * sizeof(uint16_t));
  assert(extra_bytes_n == nr * sizeof(float));
  assert(params != NULL);
  assert(kc % bl == 0);
  size_t num_blocks = kc / bl;

  int8_t* out = (int8_t*) packed_weights;
  const int32_t* b = (const int32_t*) bias;
  const uint32_t izp = (uint32_t) (((const struct xnn_qs8_qc4w_packing_params*) params)->input_zero_point + 0);

  do {
    // NC main loop multiple of ${NR}
    const uint8_t* w0 = (const uint8_t*) weights;
    const uint16_t* s0 = (const uint16_t*) scale;
    size_t n = nc;
    for (;n >= ${NR}; n -= ${NR}) {
        float* packed_k_scaled_sum = (float*) out;
        $for N in range(NR):
            ((float*) out)[${N}] = 0;
        out += ${NR} * sizeof(float);

        // KC/2 bytes is KC Nibbles
        $for N in range(1, NR):
            const uint8_t* w${N} = w${N-1} + (kc >> 1);

        // scales
        $for N in range(1, NR):
            const uint16_t* s${N} = s${N-1} + num_blocks;


        size_t kb = kc;
        // Process k by blocks (bl)
        for (; kb >= bl; kb-=bl) {
            // Initialize KSum as subtracting bl zero points (8)
            $for N in range(0, NR):
                int32_t ksum${N} = 0;
            size_t k = bl;
            for(; k >= ${2 * KR}; k-=${2*KR}) {
                $for N in range(NR):
                    $for K in range(0, KR):
                        const uint8_t v${N}x${2*K} = w${N}[${K}] & 0xF;
                        const uint8_t v${N}x${2*K+1} = w${N}[${K}] >> 4;
                    w${N} += ${KR};

                    $for K in range(0, 2*KR):
                        ksum${N} += (uint32_t) (v${N}x${K});
                    // Subtract ${2*KR} zero points (8)
                    ksum${N} -= ${8*2*KR};

                    $for K in range(0, KR):
                        out[${N*KR+K}] = (v${N}x${K} | (v${N}x${K+KR} << 4)) ^ 0x88;

                out += ${NR*KR};
            }
            $for N in range(NR):
                float scale${N} = math_cvt_fp32_bf16(s${N}[0]);
            $for N in range(NR):
                s${N} += 1;


            $for N in range(NR):
                packed_k_scaled_sum[${N}] -= (float)ksum${N} * izp * scale${N};

            $for N in range(NR):
                ((uint16_t*) out)[${N}] = math_cvt_bf16_fp32(scale${N} / 16.0f);

            out += ${NR} * sizeof(uint16_t);
        }


        if XNN_LIKELY(b != NULL){
            $for N in range(NR):
                ((uint32_t*) out)[${N}] = b[${N}];
            b += ${NR};
        } else {
            $for N in range(NR):
                ((uint32_t*) out)[${N}] = 0;
        }
        out += ${NR} * sizeof(uint32_t);
        w0 = w15;
        s0 = s15;
    }

    // NC remainder (1..${NR-1})
    if XNN_UNLIKELY(n != 0) {
        float* packed_k_scaled_sum = (float*) out;
        $for N in range(NR):
            ((float*) out)[${N}] = 0;
        out += ${NR} * sizeof(float);
        $if NR > 2:
            // NR remainder has less than ${NR}
            $for N in range(1, NR-1):
                const uint8_t* w${N} = w${N-1} + (kc >> 1);
                const uint16_t* s${N} = s${N-1} + num_blocks;
                $if $N % 2 == 0:
                    if XNN_UNPREDICTABLE(n <= ${N}) {
                        w${N} = w${N-1};
                        s${N} = s${N-1};
                    }
                $else:
                    if XNN_UNPREDICTABLE(n < ${N+1}) {
                        w${N} = w${N-1};
                        s${N} = s${N-1};
                    }

        size_t kb = kc;
        // Process k by blocks (bl)
        for (; kb >= bl; kb-=bl) {
            // Initialize KSum as subtracting bl zero points (8)
            $for N in range(0, NR-1):
                int32_t ksum${N} = 0;
            size_t k = bl;
            for(; k >= ${2 * KR}; k-=${2*KR}) {
                $for N in range(NR-1):
                    $for K in range(0, KR):
                        const uint8_t v${N}x${2*K} = w${N}[${K}] & 0xF;
                        const uint8_t v${N}x${2*K+1} = w${N}[${K}] >> 4;
                    w${N} += ${KR};

                    $for K in range(0, 2*KR):
                        ksum${N} += (uint32_t) (v${N}x${K});
                    // Subtract ${2*KR} zero points (8)
                    ksum${N} -= ${8*2*KR};

                    $for K in range(0, KR):
                        out[${N*KR+K}] = (v${N}x${K} | (v${N}x${K+KR} << 4)) ^ 0x88;

                out += ${NR*KR};
            }
            $for N in range(NR - 1):
                float scale${N} = math_cvt_fp32_bf16(s${N}[0]);
            $for N in range(NR - 1):
                s${N} += 1;


            $for N in range(NR-1):
                packed_k_scaled_sum[${N}] -= (float)ksum${N} * izp * scale${N};

            $for N in range(NR-1):
                ((uint16_t*) out)[${N}] = math_cvt_bf16_fp32(scale${N} / 16.0f);

            out += ${NR} * sizeof(uint16_t);
        }


        if XNN_LIKELY(b != NULL){
            size_t nb = n;
            do {
                *((uint32_t*) out) = *b++;
                out += sizeof(uint32_t);
            } while(--nb != 0);
        } else {
            size_t nb = n;
            do {
                *((uint32_t*) out) = 0;
                out += sizeof(uint32_t);
            } while(--nb != 0);
        }
        out += ${NR} * sizeof(uint32_t);
    }
  } while (--g != 0);
}
